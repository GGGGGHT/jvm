# GC
自动内存管理技术

## 标记-清除 Mark-Sweep 
- 标记阶段: 标记出所有可回收的对象
- 清除阶段: 回收所有已标记的对象，释放内存

## 复制算法 Copying
划分区域: 将内存区域按比例划分为1个Eden区作为分配对象的主要区域和2个幸存区(Suvivor)
复制: 将Eden区中仍戚的对象复制到某一块Suvivor中
清除: 释放Eden区和另一块幸存区

## 标记-压缩 Mark-Compact
- 标记阶段: 标记出所有可以回收的对象
- 压缩阶段: 将标记阶段的对象移动到空间的一端，释放其余空间

## 快速分配
通常情况下，系统中有大量连续的内存块可以用来分配对象，这种情况下使用`碰撞指针`算法进行对象内存空间分配的话，效率比较高


##
根据不同分代的特点，收集器可能不同，有些收集器可以同时作用于新生代和老年代，而有些时候，我们需要分别为新生代或老年代选用合适的收集器，
新生代收集器的收集频率较高，就当选用性能高效的收集器，老年代收集器收集次数相对较少，但对空间较为敏感，就当避免选用基于复制算法的收集器

在垃圾收集执行的时刻，应用程序需要暂停运行
可以串行收集，也可以并行收集
如果能做到并发收集（应用程序不必暂停）那样效率比较高
如果收集行为可控效率更高
收集器的类型决定了堆的类型，收集器掌控着诸如收集算法，对象分配策略，STW这些行为
